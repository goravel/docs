# Queues

[[toc]]

## 简介

When building your web application, there may be tasks, like parsing and storing an uploaded CSV file, that take too long to complete during a web request. Fortunately, Goravel offers a solution by allowing you to create queued jobs that can run in the background. This way, by moving time-intensive tasks to a queue, your application can respond to web requests much faster and provide a better user experience for your customers. To implement this feature, we use `facades.Queue()`.

### 连接 Vs 队列 Queues

Before delving into Goravel queues, it's important to understand the difference between "connections" and "queues". In the configuration file, `config/queue.go`, you'll find an array for `connections` configuration. This option specifies the connections to backend queue services like Redis. However, every queue connection can have multiple "queues", which can be thought of as different stacks or piles of queued jobs.

It's essential to note that each connection configuration example in the queue configuration file includes a `queue` attribute. This attribute is the default queue to which jobs will be dispatched when they are sent to a given connection. In simpler terms, if you dispatch a job without explicitly defining which queue it should be dispatched to, the job will be placed in the queue defined in the queue attribute of the connection configuration.

```go
// 这个作业被发送到默认连接的默认队列
err := facades.Queue().Job(&jobs.Test{}, []queue.Arg{
  {Type: "int", Value: 1},
}).Dispatch()

// 这个作业被发送到默认连接的"emails"队列
err := facades.Queue().Job(&jobs.Test{}, []queue.Arg{
  {Type: "int", Value: 1},
}).OnQueue("emails").Dispatch()
```

## 驱动

队列配置文件存储在 `config/queue.go` 中，可以在配置文件中设置不同的队列驱动。

### 同步调度

同步驱动是默认的驱动，它不会将任务推送到队列中，而是直接在当前进程中执行。

### 数据库驱动

为使用 `database` 驱动，需要先创建一个数据库表来存储任务：[20210101000002_create_jobs_table.go](https://github.com/goravel/goravel/blob/master/database/migrations/20210101000002_create_jobs_table.go)。该迁移文件默认在 `database/migrations` 目录下。 The migration file is located in the `database/migrations` directory by default.

### 自定义驱动

If the current driver cannot meet your needs, you can customize the driver. 如果当前驱动无法满足需求，你可以自定义驱动。需要实现 `contracts/queue/driver.go` 中的 [Driver](https://github.com/goravel/framework/blob/master/contracts/queue/driver.go#L14) 接口。

官方实现了 `Redis` 驱动，你可以参考 [Redis Driver](https://github.com/goravel/framework/blob/master/queue/drivers/redis/driver.go) 实现自己的自定义驱动。

自定义驱动实现后，可以添加配置到 `config/queue.go` 中：

```
...
"connections": map[string]any{
  "redis": map[string]any{
    "driver": "custom",
    "connection": "default",
    "queue": "default",
    "via": func() (queue.Driver, error) {
        return redisfacades.Queue("redis") // The redis value is the key of connections
    },
  },
},
```

## 创建作业

### 生成作业类

By default, all of the jobs for your application are stored in the `app/jobs` directory. 默认情况下,应用程序的所有作业都存储在`app/jobs`目录中。 如果 `app/Jobs` 目录不存在，当你运行 `make:job` Artisan 命令时将会创建它：

```shell
go run . artisan make:job ProcessPodcast
go run . artisan make:job user/ProcessPodcast
```

### 类结构

Job classes are very simple, consisting of two methods: `Signature` and `Handle`. 任务类非常简单，包含 `Signature`, `Handle` 方法，`Signature` 是任务类的唯一标识，`Handle` 在队列处理任务时将会被调用，在调用任务时传入的 `[]queue.Arg{}` 将会被传入 `Handle` 中： Additionally, the `[]queue.Arg{}` passed when the task executes will be transmitted into `Handle`:

```go
package jobs

type ProcessPodcast struct {
}

// Signature 作业的名称和签名。
func (receiver *ProcessPodcast) Signature() string {
  return "process_podcast"
}

// Handle 执行作业。
func (receiver *ProcessPodcast) Handle(args ...any) error {
  return nil
}
```

#### 调度任务

任务类支持一个可选的 `ShouldRetry(err error, attempt int) (retryable bool, delay time.Duration)` 方法，用于控制任务重试。

```go
如果您想指定一个任务不应该被队列工作者立即处理，您可以在任务分发期间使用 `Delay`
方法。 例如，让我们指定一个任务在分发后100秒内不应该可用于处理：
```

### 注册 Job

创建 job 后，你需要在 `app/provides/queue_service_provider.go` 中注册它，以便正确调用。 If the job is generated by the `make:job` command, the framework will automatically register it.

```go
func (receiver *QueueServiceProvider) Jobs() []queue.Job {
  return []queue.Job{
    &jobs.Test{},
  }
}
```

## 启动队列服务器

在根目录的 `main.go` 中启动队列服务器。

```go
package main

import (
  "github.com/goravel/framework/facades"

  "goravel/bootstrap"
)

func main() {
  // 这会引导框架并使其准备就绪。
  bootstrap.Boot()

  // 通过 facades.Queue() 启动队列服务器。
  go func() {
    if err := facades.Queue().Worker().Run(); err != nil {
      facades.Log().Errorf("队列运行错误：%v", err)
    }
  }()

  select {}
}
```

可以在 `facades.Queue().Worker` 方法中传入不同的参数，通过启动多个 `facades.Queue().Worker` 来监控多个队列。

```go
// 无参数，默认监听 `config/queue.go` 中的配置，并发数为 1
go func() {
  if err := facades.Queue().Worker().Run(); err != nil {
    facades.Log().Errorf("队列运行错误: %v", err)
  }
}()

// 监听 redis 链接的 processing 队列，并发数为 10
go func() {
  if err := facades.Queue().Worker(queue.Args{
    Connection: "redis",
    Queue: "processing",
    Concurrent: 10,
  }).Run(); err != nil {
    facades.Log().Errorf("队列运行错误: %v", err)
  }
}()
```

## 停止队列服务器

当队列服务器运行时，你可以通过调用 `Shutdown` 方法来停止队列服务器，该方法会等待当前运行中的任务完成后才会停止队列。

```go
err := facades.Queue().Worker().Shutdown()
```

## Job 类非常简单，由两个方法组成：`Signature` 和 `Handle`。 `Signature` 作为任务的唯一标识符，而 `Handle` 在队列处理任务时执行。 此外，任务执行时传递的 `[]queue.Arg{}` 将被传输到 `Handle` 中：

一旦你编写了任务类，你可以使用任务本身的 `Dispatch` 方法来调度它：

```go
package controllers

import (
  "github.com/goravel/framework/contracts/queue"
  "github.com/goravel/framework/contracts/http"
  "github.com/goravel/framework/facades"

  "goravel/app/jobs"
)

type UserController struct {
}

func (r *UserController) Show(ctx http.Context) {
  err := facades.Queue().Job(&jobs.Test{}, []queue.Arg{}).Dispatch()
  if err != nil {
    // 做一些处理
  }
}
```

### 如果你想立即（同步）调度任务，你可以使用 `DispatchSync` 方法。 使用此方法时，任务不会被加入队列，而是在当前进程中立即执行：

如果你想立即（同步）调度任务，你可以使用 `DispatchSync` 方法。使用此方法时，任务不会排队，会在当前进程内立即执行： When using this method, the job will not be queued and will be executed immediately within the current process:

```go
package controllers

import (
  "github.com/goravel/framework/contracts/queue"
  "github.com/goravel/framework/contracts/http"
  "github.com/goravel/framework/facades"

  "goravel/app/jobs"
)

type UserController struct {
}

func (r *UserController) Show(ctx http.Context) {
  err := facades.Queue().Job(&jobs.Test{}, []queue.Arg{}).DispatchSync()
  if err != nil {
    // 执行某些操作
  }
}
```

### 任务链

Job chaining allows you to specify a list of queued jobs to be executed in a specific order. If any job in the sequence fails, the rest of the jobs will not be executed. 任务链允许您指定按特定顺序执行的队列任务列表。 如果序列中的任何任务失败，其余任务将不会被执行。 要运行队列任务链，您可以使用 `facades.Queue()` 提供的 `Chain` 方法：

```go
err := facades.Queue().Chain([]queue.Jobs{
  {
    Job: &jobs.Test{},
    Args: []queue.Arg{
      {Type: "int", Value: 1},
    },
  },
  {
    Job: &jobs.Test1{},
    Args: []queue.Arg{
      {Type: "int", Value: 2},
    },
  },
}).Dispatch()
```

### 延迟分发

如果您想指定任务不应立即被队列处理，您可以在调度任务时使用 `Delay` 方法。例如，让我们指定一个任务在分派 10 分钟后处理： For example, let's specify that a job should not be available for processing after 100 seconds of dispatching:

```go
err := facades.Queue().Job(&jobs.Test{}, []queue.Arg{}).Delay(time.Now().Add(100*time.Second)).Dispatch()
```

### 自定义队列和连接

#### 分发到特定队列

通过将任务推送到不同的队列，您可以对排队的任务进行"分类"，甚至可以优先考虑分配给各种队列的工作者数量。

```go
err := facades.Queue().Job(&jobs.Test{}, []queue.Arg{}).OnQueue("processing").Dispatch()
```

#### 分发到特定连接

如果您的应用程序与多个队列连接交互，您可以使用 `OnConnection` 方法来指定任务被推送到的连接。

```go
err := facades.Queue().Job(&jobs.Test{}, []queue.Arg{}).OnConnection("sync").Dispatch()
```

您可以将 `OnConnection` 和 `OnQueue` 方法链接在一起，为任务指定连接和队列：

```go
err := facades.Queue().Job(&jobs.Test{}, []queue.Arg{}).OnConnection("sync").OnQueue("processing").Dispatch()
```

## View Failed Jobs

你可以使用 `queue:failed` 命令来获取失败任务，该命令会从数据库 `failed_jobs` 表中获取失败任务：

```shell
./artisan queue:failed
```

## 重试失败任务

If a job fails during processing, you can use the `queue:retry` command to retry the job. 如果任务在处理过程中失败，你可以使用 `queue:retry` 命令来重试该任务，在重试任务前请先从数据库 `failed_jobs` 表中获取要重试的任务 UUID：

```shell
# 重试单个任务
./artisan queue:retry 4427387e-c75a-4295-afb3-2f3d0e410494

# 重试多个任务
./artisan queue:retry 4427387e-c75a-4295-afb3-2f3d0e410494 eafdd963-a8b7-4aca-9421-b376ed9f4382

# 重试指定连接的失败任务
./artisan queue:retry --connection=redis

# 重试指定队列的失败任务
./artisan queue:retry --queue=processing

# 重试指定连接和队列的失败任务
./artisan queue:retry --connection=redis --queue=processing

# 重试所有失败任务
./artisan queue:retry all
```

## `queue.Arg.Type` 支持的类型

```go
bool
int
int8
int16
int32
int64
uint
uint8
uint16
uint32
uint64
float32
float64
string
[]bool
[]int
[]int8
[]int16
[]int32
[]int64
[]uint
[]uint8
[]uint16
[]uint32
[]uint64
[]float32
[]float64
[]string
```
